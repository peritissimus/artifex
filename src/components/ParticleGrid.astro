---
// This component loads Three.js only on the client side
// Uses client:visible to lazy-load when the canvas enters the viewport
---

<canvas id="world" class="world"></canvas>

<script>
  import * as THREE from 'three';

  class ParticleGrid {
    private canvas: HTMLCanvasElement;
    private scene: THREE.Scene;
    private camera: THREE.PerspectiveCamera;
    private renderer: THREE.WebGLRenderer;
    private mouse: THREE.Vector2;
    private targetMouse: THREE.Vector2;
    private time: number;
    private particles: THREE.Points | null = null;

    constructor() {
      this.canvas = document.getElementById('world') as HTMLCanvasElement;
      if (!this.canvas) return;

      this.scene = new THREE.Scene();
      this.camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      // Optimize WebGL renderer for mobile
      const isMobile = window.innerWidth < 768;
      this.renderer = new THREE.WebGLRenderer({
        canvas: this.canvas,
        alpha: true,
        antialias: !isMobile,
        powerPreference: 'high-performance',
      });

      this.mouse = new THREE.Vector2();
      this.targetMouse = new THREE.Vector2();
      this.time = 0;

      this.init();
      this.createParticles();
      this.addEventListeners();
      this.animate();
    }

    private init() {
      this.renderer.setSize(window.innerWidth, window.innerHeight);

      const isMobile = window.innerWidth < 768;
      const maxPixelRatio = isMobile ? 1 : 2;
      this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, maxPixelRatio));

      this.camera.position.z = 50;

      // Fade in canvas once loaded
      setTimeout(() => {
        this.canvas.classList.add('loaded');
      }, 100);
    }

    private createParticles() {
      const geometry = new THREE.BufferGeometry();

      const isMobile = window.innerWidth < 768;
      const particleCount = isMobile ? 400 : 2000;

      const positions = new Float32Array(particleCount * 3);
      const scales = new Float32Array(particleCount);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 100;
        positions[i3 + 1] = (Math.random() - 0.5) * 100;
        positions[i3 + 2] = (Math.random() - 0.5) * 30;
        scales[i] = Math.random();
      }

      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('scale', new THREE.BufferAttribute(scales, 1));

      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uMouse: { value: new THREE.Vector2() },
          uOpacity: { value: 0.5 },
        },
        vertexShader: `
          attribute float scale;
          uniform float uTime;
          uniform vec2 uMouse;

          varying float vScale;

          void main() {
            vScale = scale;

            vec3 pos = position;

            // Subtle wave motion
            pos.z += sin(uTime * 0.5 + position.x * 0.1) * 0.5;
            pos.z += cos(uTime * 0.3 + position.y * 0.1) * 0.5;

            // Mouse interaction (subtle)
            float dist = distance(position.xy, uMouse * 50.0);
            float force = smoothstep(10.0, 0.0, dist);
            pos.z += force * 2.0;

            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = scale * 2.0 * (50.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;
          }
        `,
        fragmentShader: `
          uniform float uOpacity;
          varying float vScale;

          void main() {
            vec2 uv = gl_PointCoord - vec2(0.5);
            float dist = length(uv);
            float alpha = smoothstep(0.5, 0.1, dist);

            vec3 color = vec3(0.81, 0.81, 0.79);

            gl_FragColor = vec4(color, alpha * uOpacity * vScale);
          }
        `,
        transparent: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
      });

      this.particles = new THREE.Points(geometry, material);
      this.scene.add(this.particles);
    }

    private addEventListeners() {
      window.addEventListener('resize', () => this.onResize());
      window.addEventListener('mousemove', (e) => this.onMouseMove(e));
    }

    private onResize() {
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    private onMouseMove(event: MouseEvent) {
      this.targetMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      this.targetMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    private animate() {
      requestAnimationFrame(() => this.animate());

      this.time += 0.01;

      this.mouse.x += (this.targetMouse.x - this.mouse.x) * 0.05;
      this.mouse.y += (this.targetMouse.y - this.mouse.y) * 0.05;

      if (this.particles && this.particles.material) {
        (this.particles.material as THREE.ShaderMaterial).uniforms.uTime.value = this.time;
        (this.particles.material as THREE.ShaderMaterial).uniforms.uMouse.value = this.mouse;
      }

      if (this.particles) {
        this.particles.rotation.y = Math.sin(this.time * 0.1) * 0.1;
      }

      this.renderer.render(this.scene, this.camera);
    }
  }

  // Initialize only in HUMAN mode
  if (document.body.dataset.mode === 'human') {
    new ParticleGrid();
  }
</script>

<style lang="scss">
  @use '../styles/variables' as *;

  .world {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: $z-canvas;
    opacity: 0;
    transition: opacity 0.5s ease;

    &:global(.loaded) {
      opacity: 1;
    }
  }
</style>
